# 线程与进程的区别和联系

+ 进程比线程更轻量，创建更快、销毁也更快。
+ 直观理解：进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务。
+ 系统角度：进程是操作系统资源分配的基本单位，线程是操作系统调度执行的基本单位。
+ 不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间（例如共同使用同一个变量）。

# 并行与并发有什么区别

现在都是多核CPU，在多核CPU下

+ 并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU
+ 并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程

# 创建线程的方式

+ 继承Thread类
+ 实现runnable接口
+ 实现Callable接口
+ 线程池创建线程(项目中使用方式)

追问：

1. **使用runnable和callable都可以创建线程，它们有什么区别呢？**

答：

+ Runnable 接口run方法没有返回值
+ Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果
+ Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛。

```java
// 使用Runnable
Runnable myRunnable = () -> {
    // 任务逻辑
    System.out.println("Runnable task");
};

// 使用Callable
Callable<String> myCallable = () -> {
    // 任务逻辑
    return "Callable task";
};
```

2. **线程的run()和start()有什么区别？**

答：

+ run()是一个封装了要被执行代码的普通方法，直接调用run方法是不能启动线程的，可以被调用多次。
+ 而start方法的底层是由JVM调用start0方法，来开启线程，通过该线程调用run方法执行run方法中所定义的逻辑代码，只能被调用一次。

# 线程间的状态

![1701229790009](image/2023-11-28-Int_java多线程/1701229790009.png)

+ `new Thread()`后，线程首先进入 **New(初始)** 状态，调用`start()`后开始运行，线程这时候处于 **Ready(就绪)** 状态，当Ready的线程获得CPU执行权后就处于 **Running(运行)** 状态，执行完成后进入 **Terminated(终止状态)**。这是一个大致的流程，当线程处于 **Runnable(可运行状态)** 时，会通过执行方法变成其它状态。
+ 当线程执行`wait()`方法之后，线程进入 **Waiting(等待)** 状态，进入等待状态的线程需要依靠其它线程的通知才能够返回到运行状态。
+ **Time_Waiting(超时等待)** 状态相当于在等待的基础上增加了超时限制，比如通过`sleep(long millis)`方法或`wait(long millis)`方法可以将线程置于Time_Waiting状态。当超时时间结束后，线程将会返回到Runnable状态。
+ 当线程进入`synchronized`方法/代码块，锁被其它线程占有，这时线程进入 **Blocked(阻塞)** 状态。
# wait和sleep方法的区别
主要在于锁特性的不同：
+ wait方法的调用必须先获取wait对象的锁，对应了wait与synchronized是配套使用的，而sleep则无此限制。
+ wait方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃CPU，但你们还可以用）
+ sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃CPU，你们也用不了）


