# SpringBoot Web基础
## http协议
### 概述
超文本传输协议，规定了浏览器和服务器之间数据传输的格式
特点：
:::tips

1. 基于TCP协议：面型连接，安全
2. 基于请求-响应模型的：一次请求对应一次响应
3. HTTP协议是无状态的协议：对于事务处理没有记忆能力，每次请求-响应都是独立的
- 缺点：多次请求间不能共享数据
- 优点：速度快
:::
### 请求协议
#### 请求数据格式
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689818372559-565b18d3-1b7e-4763-ad34-d0a7eb3f87d3.png#averageHue=%23f8e7cc&clientId=uc04519ff-564d-4&from=paste&height=514&id=u72e3936b&originHeight=643&originWidth=1541&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=478794&status=done&style=none&taskId=u59af84e4-312e-4fb0-9b6c-e5876fc679b&title=&width=1232.8)
HTTP请求分为4个部分：

1. 请求行（首行），包含三个部分

        1）请求方式：方法大概描述了这个请求想完成什么工作。
        2）URL：描述了要访问的网络上的资源具体在哪
        3）版本号；HTTP/1.1表示当前使用的HTTP版本是1.1，1.1是当前最主流的版本，还可能是其他版本。

2. 请求头（header），有很多行

       每一行都是一个键值对

3. 空行

       相当于请求头的结束标记，类似于链表的null

4. 请求正文（body）

       里面的格式非常灵活，取决于请求头中的Content-Type
      1) x-www-form-urlencoded
         格式和query string是一样的，也是键值对的结构，键值对之间使用&来分割，键和值之       间使用=分割，并且需要进行urlencode
      2) form-data 上传文件
      3) json
         {}构成的若干个键值对；键和值之间使用：分割；键值对之间使用逗号分割
#### 请求方式

- get : 请求参数在请求行中，没有请求体，如：/brand/findAll?name=wmy&status=1。get请求大小是有限制的。
- post : 请求参数在请求体中，post请求大小是没有限制的
### 响应协议
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689819178883-b3404c9c-d097-4eaf-a2c6-66a4b23967dc.png#averageHue=%23f9ecce&clientId=u8c018b86-f2f1-4&from=paste&height=227&id=u687607a6&originHeight=284&originWidth=1484&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=169443&status=done&style=none&taskId=u60189fc8-6ed0-4d16-8935-e82bd6a2e66&title=&width=1187.2)
HTTP响应也分为4个部分：

1. 响应行

      包含三个部分：版本号，状态码，状态码得描述

2. 响应头

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689819871966-904af425-b88d-4d82-8b82-9ef0ce8af591.png#averageHue=%23f2e4c5&clientId=u8c018b86-f2f1-4&from=paste&height=220&id=u10e6a97e&originHeight=275&originWidth=1463&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=166790&status=done&style=none&taskId=u0d702a64-ae89-4c4e-aff7-b78547c4f17&title=&width=1170.4)

3. 空行

       表示响应头的结束标记

4. 响应正文

        服务器返回给客户端的具体数据，这里的东西可能有各种不同的格式，具体取决于      Content-Type  
## HTTP请求详细解释
### URL
URL含义就是“网络上唯一资源的地址符”，该地址符既要明确主机是谁，又要明确取主机上的哪个资源。其具体格式如下：
![1d5cdd8ba27a4ea49f246bef144a22ab.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1699003173738-c3ad9fbb-abea-4338-9404-cdd21455a558.png#averageHue=%23fbfaf8&clientId=ueb7aff1e-86db-4&from=drop&id=ucb1456ec&originHeight=169&originWidth=822&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47952&status=done&style=none&taskId=u67b10b04-fcb9-4335-8211-93cfbb8f184&title=)
**协议方案名：**
描述了当前这个URL是给哪个协议来使用的；http:// 给HTTP用；https:// 给HTTPS用；jdbc:mysql:// 给jdbc:mysql 用。
**登录信息：**
指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。
**服务器地址：**
表明当前要访问的主机。这里可以是一个IP地址，也可以是域名。
**服务器端口号：**
表示当前要访问的主机上的哪个应用程序（端口号大部分情况下是省略的）
**带层次的文件路径：**
描述了当前要访问的服务器的资源是什么。
**查询字符串（query string）：**
是浏览器/客户端给服务器传递的自定义（由程序猿自己定义）的信息，相当于对获取到的资源提出了进一步的要求。
查询字符串的内容也是键值对结构；查询字符和路径之间由？来分割
**片段标识符：**
描述了要访问当前html页面中哪个具体的子部分，能够控制浏览器滚动到相关位置。
### 方法
请求行里的方法，描述了这个请求响应想要完成的工作：
![bac0a3d8a9e44ab19e4c4e8f58e7fa46.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1699003872452-792b9d23-f377-430b-a06b-e5550c2b3d4f.png#averageHue=%23fbf9f8&clientId=ueb7aff1e-86db-4&from=drop&id=u74d7b6a4&originHeight=486&originWidth=833&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=93275&status=done&style=none&taskId=udaeda290-0084-46db-a13d-e787078f13f&title=)

**get和post的区别？**

1. 数据位置：

      GET 方法将数据附加在 URL 的查询参数中，作为请求的一部分，例如：http://example.com/path?param1=value1&param2=value2。而 POST 方法将数据包含在请求的正文中，以供服务器处理。

2. 数据长度限制：

      GET 方法对传输的数据长度有限制，不同浏览器和服务器可能有不同的限制，一般限制在几千个字符之内。而 POST 方法没有特定的数据长度限制。

3. 安全性：

       GET 方法的参数数据会显示在 URL 上，因此对于包含敏感信息（如密码）的数据，不适合使用 GET 方法传输。POST 方法的数据在请求正文中，不会直接显示在 URL 上，相对更安全。

4. 结果的幂等：

       所谓的「幂等」，意思是多次执⾏相同的操作，结果都是「相同」的。（不幂等就是多次执行相同的操作，结果却不同）。
       GET请求一般是幂等的，POST请求一般不幂等。

5. 能否被缓存：

      GET可以被缓存，POST不能被缓存
      如果结果是幂等的，可以提前把结果记住，节省了下次访问的开销；但如果是不幂等的，就不应该去记。
### 请求头
在请求报头（header）中，是一些键值对，不同的键值对表示了不同的含义，下面是一些常用的键值对。

1. **host**

       客户端发送请求时，用来指定服务器的域名。
![709cb668d20e4f88a6114ef52e67fcf0.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1699005309438-88c2c1d7-283d-49e4-a828-4c07acfdff4b.png#averageHue=%23f9f7f4&clientId=ueb7aff1e-86db-4&from=drop&id=u07a2b018&originHeight=431&originWidth=790&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=108523&status=done&style=none&taskId=ub8dacaa0-631b-4ca3-a41b-5ae841a2997&title=)
有了Host字段，就可以将请求发往「同⼀台」服务器上的不同网站

2. **Content-Length**

       表示body中的数据长度
![663b743be09a41de9d091616e42662b8.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1699005378456-73cdf492-7a4c-4e72-81ba-fdd37dfc14f4.png#averageHue=%23fdfefc&clientId=ueb7aff1e-86db-4&from=drop&id=uf64cd4c6&originHeight=286&originWidth=565&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=78933&status=done&style=none&taskId=ue9fdfc51-2117-4e5d-ad7c-a14492bb8f6&title=)
上述的代码表示本次请求的数据长度是1000个字节，后面的字节就属于下一个请求了。（该方法类似于解决TCP协议中的粘包问题）

3. **Content-Type**

       表示请求的body中的数据格式。

4. User-Agent(简称UA)

       表示浏览器/操作系统的属性
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1699005498815-add5a9ca-33db-4832-b016-945645a0f5fa.png#averageHue=%23282828&clientId=ueb7aff1e-86db-4&from=paste&height=29&id=uaa13a462&originHeight=36&originWidth=1100&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=6376&status=done&style=none&taskId=u7db94db2-9db8-4694-8ea4-8d357c3b115&title=&width=880)
之前为了适应不同版本的浏览器，如今最大的用处是用于区分PC端还是手机端。
让浏览器自报家门，以让服务器做出区分。

5. **Referer**

       表示当前的页面，是从哪个页面跳转过来的。

6. **Cookie**

       Cookie是浏览器给页面提供的一种能够持久化存储数据的机制。（持久化指的是，数据不会因为程序重启或者主机重启而丢失）
Cookie具体的组织形式如下：
      1、先按照域名来组织，针对每个域名，分配一块空间。
      2、在这块空间里，又会按照键值对的方式来组织数据。
但在浏览器上存储，始终是容易丢失的，所以这些关键信息，还是存储在服务器上靠谱，这个东西叫做“session”
服务器管理着很多很多的session，每个session里面都存储了用户的关键信息，每个session也都有一个sessionId(会话的标识)
Cookie最重要的应用场景，就是存储会话id，进一步让访问服务器的后续页面的时候，能够带上这个id，从而让服务器能够知道当前用户的信息（服务器上保存用户信息这样的机制，就称为Session会话）。
## HTTP响应详细解释
### 状态码
[状态码文档](https://cloud.tencent.com/developer/chapter/13553)
### 响应报头
响应报头的基本格式和请求头的格式基本一致。类似于Content-Length等属性的含义也和请求中的含义一致,Content-Type有所差别。
## HTTP加密
### 什么是HTTPS
由于HTTP是明文传输，所以在传递过程中有被篡改的风险，为了解决这个风险，HTTPS在HTTP的基础上加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输，更好的保护数据安全。
### 加密
#### **对称加密**
对称加密其实就是通过一个“密钥”，把明文加密成密文，并且也能把密文解密成明文。
![4708a90714ba4c7180eec942828ff8ff.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1699016372125-3974b6f0-7e2f-4a51-83ae-29d29011d5e4.png#averageHue=%23d3e6d0&clientId=u0621ccf9-c68c-4&from=drop&id=u5278d5e9&originHeight=387&originWidth=797&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40180&status=done&style=none&taskId=u257eb1fb-8c18-4d6b-9353-5495d60a822&title=)
如上图所示，客户端用密钥将明文加密成密文，向服务器发送密文请求，服务器接收到密文请求后再利用密钥将密文进行解密，拿到明文。
此时客户端和服务器持有同一个密钥，但若在一个服务器对应很多个客户端时，必须对应有不同的密钥才行，如果所有客户端都用同一个密钥，黑客就很容易获取到这个密钥了。
为了解决上述的问题，就需要客户端或者服务器任意一方主动生成密钥，并传输给对方，如下图所示。
![a4e2e089-7963-452b-9252-5a01707e0a76.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1699016902203-356db24c-ecf7-452e-8e9f-d38662d79bce.png#averageHue=%23d3e6d0&clientId=u0621ccf9-c68c-4&from=drop&id=u782ca06b&originHeight=359&originWidth=776&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49426&status=done&style=none&taskId=uf607ab3c-5f3a-40e7-9ac3-da0b1e33baf&title=)
同样的，密钥进行明文传输，也会被黑客劫持到，有数据安全风险，所以我们需要**针对密钥再进行加密**，就用到了下边介绍的非对称加密。
#### **非对称加密**
非对称加密有两个密钥，公钥和私钥                                                                                    公钥，就是人人都可以获取到；私钥，就是只有自己知道
我们就可以通过使用公钥来加密，私钥来解密；或者使用私钥来加密，公钥来解密。（公钥和私钥之间的相互推导计算量很大，实际上不容易实现）
通过对称加密和非对称加密相结合的方法，有以下的加密方式：                                            客户端生成一个对称密钥，客户端可以使用服务器的公钥，来对对称密钥进行加密，然后把数据传给服务器。服务器再通过私钥进行解密，得到对称密钥，再利用对称密钥解密得到明文。
在服务器获取到对称密钥以后，客户端和服务器之间的通信都只用对称密钥即可。                 由于该密钥只有客户端和服务器两个主机知道，其他主机/设备不知道密钥，即使截获数据也没有意义。
由于对称加密的效率比非对称加密高很多，因此只是在开始阶段协商密钥时，使用非对称加密，后续的传输仍然使用对称加密
![9161c3b219ff44d29844e6bb2d5b8ec4.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1699017797970-926d73e1-03be-4c81-9fba-b38c150b946c.png#averageHue=%23d3e5ce&clientId=u0621ccf9-c68c-4&from=drop&id=u73da8735&originHeight=404&originWidth=772&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=85448&status=done&style=none&taskId=u90b9f6df-0649-4070-a583-100d854bf05&title=)
那么接下来问题又接踵而至：

- 客户端如何获取到公钥？
- 客户端如何确定这个公钥是不是黑客伪造的？
#### 引入证书
在客户端和服务器刚一建立连接的时候，服务器给客户端返回一个证书。
这个证书包含了刚才的公钥，也包含了网站的身份信息。
> 这个证书就好比人的身份证，作为这个网站的身份标识。搭建一个HTTPS网站要先在第三方机构申请一个证书（类似于去公安局办个身份证）

![8eb61ff3e92b4cc8ab4df772a3b75fcc.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1699017963322-fd991f30-124a-4948-a99e-1b704e31fabd.png#averageHue=%23d4e5ce&clientId=u0621ccf9-c68c-4&from=drop&id=uf408558a&originHeight=548&originWidth=776&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=109482&status=done&style=none&taskId=ua9f5a019-a5f1-4683-9200-5d28d2146cd&title=)
通过在公信机构上已经登记的证书，客户端可以进行验证此时收到的公钥是不是合理的，如果合理再建立连接，进行下一步的数据传送。
## 请求响应
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689831455771-ae85a410-ec96-45a4-8fb4-a8311768dfc8.png#averageHue=%23f2dee1&clientId=ue5d4d9cc-545a-4&from=paste&height=158&id=GQ0oV&originHeight=197&originWidth=1279&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=100289&status=done&style=none&taskId=u72abfe99-f7c2-4240-970d-f829c2ceffe&title=&width=1023.2)
### 请求
#### 简单参数

- **原始方式：**

在原始的web程序中，获取请求参数，需要通过HttpServletRequest对象手动获取
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689837465880-a2ab4530-9845-46b2-a471-c536f94a3742.png#averageHue=%23f9f4ed&clientId=ue5d4d9cc-545a-4&from=paste&height=502&id=uaef4aed7&originHeight=627&originWidth=1612&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=309710&status=done&style=none&taskId=ue1dfafcd-e144-485e-a019-7cad736ed18&title=&width=1290)

- **springboot方式：**

简单参数：参数名与形参变量名相同，定义形参即可接收参数。
写法：
```java
@RequestMapping("/simpleParam")
    public String simpleParam(String name, Integer age) {
        System.out.println(name + ":" + age);
        return "OK";
    }
```
**get方式：**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689840501674-49b6f46c-e6e6-4ef8-9b37-26015a28e8c3.png#averageHue=%23fcfbfb&clientId=ue5d4d9cc-545a-4&from=paste&height=446&id=u7e13a88e&originHeight=557&originWidth=945&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=59296&status=done&style=none&taskId=u2e577e32-e4e1-4639-8633-7e1a245beb0&title=&width=756)
**post方式**：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689840523435-65b0e9f1-4efe-42ca-a34b-c473c91dbf13.png#averageHue=%23fcfbfb&clientId=ue5d4d9cc-545a-4&from=paste&height=445&id=u5408d349&originHeight=556&originWidth=923&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=56996&status=done&style=none&taskId=u904d8c5a-5dfa-437d-bd5e-a20e428b96b&title=&width=738.4)

- **@RequestParam**

简单参数：如果方法形参名称与请求参数名称不匹配，可以使用@RequestParam完成映射。
写法：
```java
@RequestMapping("/simpleParam")
    public String simpleParam(@RequestParam(name = "name") String username, Integer age) {
        System.out.println(username + ":" + age);
        return "OK";
    }
```
#### 实体参数

- **简单实体对象：**

请求参数名与形参对象属性名相同，定义POJO接收即可
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689838952728-7ef0b499-10d3-45b5-9264-a7d7b98b63c1.png#averageHue=%23faf9f3&clientId=ue5d4d9cc-545a-4&from=paste&height=625&id=u4ddd59b2&originHeight=781&originWidth=1455&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=313802&status=done&style=none&taskId=ua5fe4366-379a-4c7b-b0eb-e29054a1a3b&title=&width=1164)

- **复杂实体对象：**

请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689841153910-4312d2f1-6249-490e-9854-942e3b706af0.png#averageHue=%23f8f6f0&clientId=ue5d4d9cc-545a-4&from=paste&height=583&id=u7232338d&originHeight=729&originWidth=1534&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=420007&status=done&style=none&taskId=ud6b6a99b-1395-4287-9342-b4c7bd4e08f&title=&width=1227)
#### 数组集合参数

- **数组参数：**

请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数
写法：
```java
@RequestMapping("/arrayParam")
    public String arrayParam(String[] hobby) {
        System.out.println(Arrays.toString(hobby));
        return "OK";
    }
```
postman中get方式：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689843258044-c07ca52a-70a8-4d81-baac-7791b22a09a0.png#averageHue=%23fbfbfa&clientId=ue5d4d9cc-545a-4&from=paste&height=456&id=uea6ac7bd&originHeight=570&originWidth=936&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=66211&status=done&style=none&taskId=ue2f64ef4-e92e-49e1-9983-34efa805abd&title=&width=748.8)

- **集合参数：**

请求参数名与形参集合名称相同且请求参数为多个，@RequestParam绑定参数关系
写法：
```java
 @RequestMapping("/listParam")
    public String listParam(@RequestParam List<String> hobby) {
        System.out.println(hobby);
        return "OK";
    }
```
#### 日期参数
使用@DateTimeFormat注解完成日期参数格式转换
写法：
```java
@RequestMapping("/dateParam")
    public String dateParam(@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") LocalDateTime updateTime) {
        System.out.println(updateTime);
        return "OK";
    }
```
postman的get方式
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689845924158-e49783ff-d17d-4107-9188-5b31c4c492ee.png#averageHue=%23fbfbfa&clientId=ue5d4d9cc-545a-4&from=paste&height=262&id=u25ad916e&originHeight=327&originWidth=936&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=43022&status=done&style=none&taskId=uc4e29176-5c4b-49e3-917f-d954c4e2624&title=&width=748.8)
#### JSON参数
JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数，需要使用@RequestBody
写法：
```java
@RequestMapping("/jsonParam")
    public String jsonParam(@RequestBody User user) {
        System.out.println(user);
        return "OK";
    }
```
post方式：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689846096583-516494c2-5626-49b5-9065-5d6424b60f73.png#averageHue=%23fdfcfc&clientId=ue5d4d9cc-545a-4&from=paste&height=375&id=uc2f56d7e&originHeight=469&originWidth=912&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=45541&status=done&style=none&taskId=ufbeb8257-0ff1-429c-a38d-bc3a51e83c3&title=&width=729.6)
#### 路径参数
通过请求URL直接传递参数，使用{...}来标识该路径参数，需要使用@PathVariable获取路径参数
写法：
```java
 @RequestMapping("/path/{id}")
    public String pathParam(@PathVariable Integer id) {
        System.out.println(id);
        return "OK";
    }
```
上面是传递单个参数，若要传递多个参数，则按下面这种写法：
```java
 @RequestMapping("/path/{id}/{name}")
    public String pathParam2(@PathVariable Integer id, @PathVariable String name) {
        System.out.println(id);
        System.out.println(name);
        return "OK";
    }
```
get方式：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689846260824-b65a6599-075a-4b6c-85a7-c16ce35f203e.png#averageHue=%23fcfbfa&clientId=ue5d4d9cc-545a-4&from=paste&height=156&id=uea62ffa3&originHeight=195&originWidth=950&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=24934&status=done&style=none&taskId=u54f36a77-232a-4ce7-a45c-3501aa983ca&title=&width=760)
### 响应
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689846524110-92670b9c-1bf8-4e42-9387-8f21cf19d512.png#averageHue=%23f9f6f3&clientId=ue5d4d9cc-545a-4&from=paste&height=423&id=u6caec4de&originHeight=529&originWidth=1079&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=159371&status=done&style=none&taskId=uf61b19bc-8bf0-42fb-99d1-2b784fe17ef&title=&width=863.2)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689848145369-17d7a3d2-b16a-4dd6-be78-b872bea842d4.png#averageHue=%23fbf7ed&clientId=ue5d4d9cc-545a-4&from=paste&height=651&id=u1e72034b&originHeight=814&originWidth=1530&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=424619&status=done&style=none&taskId=uf6ba7752-79f0-4e3e-b911-7d77b783712&title=&width=1224)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689849160483-d2f9b2f2-4cae-41b5-ae5d-238bb8dbe1de.png#averageHue=%23f9f8f1&clientId=ue5d4d9cc-545a-4&from=paste&height=298&id=uc5787bbd&originHeight=373&originWidth=663&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=67495&status=done&style=none&taskId=uea4e64ae-8c3a-4105-a975-e5bf2a284c5&title=&width=530.4)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689849549543-afdb11cb-8c67-469d-a40f-ce696dfe560e.png#averageHue=%23f5eeeb&clientId=ue5d4d9cc-545a-4&from=paste&height=648&id=u9643d482&originHeight=810&originWidth=1555&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=657135&status=done&style=none&taskId=u37ccaadd-c92b-410f-8f27-2bbbd32bc0b&title=&width=1244)
# SpringBoot Web开发
## 分层解耦

---

### 三层架构
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689937802118-1101130a-df0f-4e0c-bf44-05c52306adfa.png#averageHue=%23f9f5ed&clientId=u000b8e02-5f39-4&from=paste&height=629&id=u3c42252d&originHeight=786&originWidth=1423&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=160559&status=done&style=none&taskId=u3781bb53-2629-4a84-a50d-c2ce005bc3c&title=&width=1138.4)
具体步骤：
前端用户发起请求到Controller，由Controller层负责接收请求，响应数据，调用service层中的方法，而service层只负责逻辑处理，要获取数据，需在service中调取Dao,由Dao查询数据，再将数据返回给service, serivce拿到数据后，再进行逻辑处理，将处理后的结果返回给Controller程序，最终controller把结果响应给前端。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689947568466-b445833c-1aa0-4675-aa79-aec2bfbdfedd.png#averageHue=%23f5edd9&clientId=u000b8e02-5f39-4&from=paste&height=626&id=uc694b98e&originHeight=783&originWidth=1563&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=650330&status=done&style=none&taskId=u0284a6de-d8be-4c19-aadb-57a34d02190&title=&width=1250.4)
### 分层解耦思想
#### 高内聚低耦合
内聚：软件中各个功能模块内部的功能联系
耦合：衡量软件中各个层/模块之间的依赖、关联的程度
#### 思想分析
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689948461564-97642d47-3163-4f33-97e4-e3f92739c155.png#averageHue=%23faf9f9&clientId=u000b8e02-5f39-4&from=paste&height=496&id=ub50dfe81&originHeight=620&originWidth=1620&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=429645&status=done&style=none&taskId=u68db44f7-069b-4eff-866b-65c83d90037&title=&width=1296)
上图：service层的代码改动，那么controller层也要改动，这样代码就耦合了
如何解耦呢？
controller层不要new service层的对象，那此时controller层的empService如何获取值呢？
我们可以创造一个容器，用来存储对象，这样把EmpService对象A存储到容器中,此时controller对象运行时需要依赖到EmpService,就到容器里去找EmpService的对象，从而赋值给empService。如果EmpService的对象改动了，就在容器里再存储一个对象，这样重复操作，即使service层的代码改动了，controller层也不用改动，成功解耦。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689949268703-08bfe9d8-a64b-4105-880a-788d59db770f.png#averageHue=%23fbf9f7&clientId=u000b8e02-5f39-4&from=paste&height=642&id=uafb644a2&originHeight=802&originWidth=1618&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=456714&status=done&style=none&taskId=ua003923d-255a-4413-a06d-3c0322c513c&title=&width=1294.4)
### IOC&依赖注入
由分层解耦得出问题：对象怎么样交给容器去管理？容器如何为程序提供所依赖的资源？
这就用到控制反转和依赖注入。
:::tips
控制反转：IOC,对象的创建控制权由程序自身转移到外部容器，这种思想称为控制反转。
依赖注入：容器为应用程序提供运行时所依赖的资源，称为依赖注入。
Bean对象：IOC容器中创建、管理的对象，称为bean.
:::
#### 入门
为入门程序进行IOC和依赖注入：
第一步：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689950707383-5be8a81d-cf0a-41a5-b491-94cd780ddb0a.png#averageHue=%23faf8e8&clientId=u000b8e02-5f39-4&from=paste&height=534&id=u52090a99&originHeight=668&originWidth=1476&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=302256&status=done&style=none&taskId=ub51f9388-74ea-4d84-acc1-5cee7b5c5eb&title=&width=1180.8)
第二步：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689950748908-0c92225e-6a9f-456a-94f6-36f834f7b980.png#averageHue=%23f9f7e5&clientId=u000b8e02-5f39-4&from=paste&height=418&id=u95a89df2&originHeight=523&originWidth=1481&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=296949&status=done&style=none&taskId=u36ae4aab-c207-415d-8725-c5f47a9ed64&title=&width=1184.8)
这样两步就完成了IOC与依赖注入。
如果要把EmpServiceA换成EmpSerivceB,将B的对象交给容器，就取消A的@Component注解，从而添加给B就OK了。
#### IOC详解
##### bean的声明
要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一：

| 注解 | 说明 | 位置 |
| --- | --- | --- |
| @Component | 声明bean的基础注解 | 不属于以下三类时，用此注解 |
| @Controller | @Component的衍生注解 | 标注在Controller类上 |
| @Service | @Component的衍生注解 | 标注在Service类上 |
| @Repository | @Component的衍生注解 | 标注在数据访问类上（由于与Mybatis整合，用的少） |

注意：
:::tips
在springboot集成web开发中，声明控制器bean只能用@Controller
:::
**Bean组件扫描：**
:::tips

- 前面声明bean的四大注解，要想生效，还需要被组件扫描，注解@ComponentScan扫描。
- @ComponentScan注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解@SprinaBootApplication中，默认扫描的范围是启动类所在包及其子包。
:::
#### 依赖注入详解
@Autowired注解，默认是按照类型进行，如果存在多个相同类型的bean，将会报错。
通过以下几种方式解决：

1. @Primary

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689953196044-3fd3db09-ec58-434c-a5ad-d56a3fda19c2.png#averageHue=%23f9f7df&clientId=u000b8e02-5f39-4&from=paste&height=85&id=uf2f2748c&originHeight=106&originWidth=350&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=24274&status=done&style=none&taskId=ubd9208dd-1cca-4bb5-82e0-df2b22eda45&title=&width=280)

2. @Qualifier

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689953240469-95d1955e-f4ce-432a-9011-b303140c148b.png#averageHue=%23f6f4db&clientId=u000b8e02-5f39-4&from=paste&height=106&id=u5216af0c&originHeight=133&originWidth=241&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36407&status=done&style=none&taskId=u09b47b88-c496-4c93-a952-a844505ac2c&title=&width=192.8)

3. @Resource

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689953280474-573eca49-d246-4a67-8b26-d4e4fbe4255e.png#averageHue=%23f5f3db&clientId=u000b8e02-5f39-4&from=paste&height=81&id=u0d3d5c12&originHeight=101&originWidth=291&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32213&status=done&style=none&taskId=u77a3a06e-1bfe-43b9-a00f-2981c414fa8&title=&width=232.8)
面试题：@Resource与@Autowired区别
:::tips
@Autowired是spring框架提供的注解，而@Resource是JDK提供的注解
@Autowired默认是按照类型注入，而@Resource默认是按照名称注入
:::
## spring事务管理

---

- 事务：

事务 是一组操作的集合，它是一个不可分割的工作单位，这些操作 要么同时成功，要么同时失败。

- 案例介绍：

解散部门：删除部门，同时删除该部门下的员工
```java
@Transactional //spring事务管理
    @Override
    public void delete(Integer id) {
        //根据ID删除部门
        deptMapper.deleteById(id);

        int i = 1/0; //模拟异常
        
        //根据部门ID删除该部门下的员工
        empMapper.deleteByDeptId(id);
    }
```
:::tips
注解：@Transactional
位置：业务（service）层的方法上、类上、接口上
作用：将当前方法交给spring进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务
:::
## 登录校验

---

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1693916382128-3f956b76-2e07-414a-97ec-e86816b2ddcc.png#averageHue=%23f9f1e0&clientId=uf6f6c2b6-015e-4&from=paste&height=488&id=u589e09aa&originHeight=610&originWidth=1209&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=72167&status=done&style=none&taskId=uc5341f35-aeb0-426c-b271-a5f016c2650&title=&width=967.2)
### 会话技术
#### 会话
:::tips
用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应
:::
#### 会话跟踪
:::tips
一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。
:::
#### 会话跟踪技术
:::tips
浏览器与服务器交互使用http协议，而http协议是无状态的，下一次请求不会携带上一次请求的数据，两次请求都是独立的，服务端就无法分辨两次请求是否来自同一个会话，所以两次请求间无法数据共享，要解决这个问题，就需要使用**会话跟踪技术**，主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。
:::
#### 客户端会话跟踪技术Cookie
:::tips
 cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
:::
:::tips
优点：HTTP协议中支持的技术
缺点：1. 移动端APP无法使用Cookie
          2. 不安全，用户可以自己禁用Cookie
          3. Cookie不能跨域
:::
#### 服务端会话跟踪技术Session
:::tips
session 是另一种记录服务器和客户端会话状态的机制
session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中
:::
:::tips
优点：存储在服务端，安全
缺点：1. 服务器集群环境下无法直接使用Session
          2. Cookie的缺点
:::
:::tips
session认证流程：

1. 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session
2. 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器
3. 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
4. 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。
:::
## AOP

---

### AOP概述
动态代理是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。
实现步骤：

1. 导入依赖
2. 编写AOP程序
```java
@Slf4j
@Component
@Aspect //AOP类
public class TimeAspect {

    @Around("execution(* com.wmy.service.*.*(..))") //切入点表达式
    public Object recordTime(ProceedingJoinPoint joinPoint) throws Throwable {
        //1.记录开始时间
        long begin = System.currentTimeMillis();

        //2.调用原始方法运行
        Object result = joinPoint.proceed();

        //3.记录结束时间，计算方法执行耗时
        long end = System.currentTimeMillis();
        log.info(joinPoint.getSignature() + "方法执行时间：{}ms", end-begin);

        return result;
    }
}
```
### AOP核心概念
:::tips
连接点：JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）
通知：Advice，指哪些重复的逻辑，也就是共性功能（最终体现为一个方法）
切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用
切面：Aspect，描述通知与切入点的对应关系（通知+切入点）
目标对象：Target，通知所应用的对象
:::
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1690615141178-d03cb7aa-ca48-4350-a87b-ed249c3d9622.png#averageHue=%23f7e1df&clientId=ue1c9f8db-193a-4&from=paste&height=394&id=uddf6839e&originHeight=493&originWidth=1239&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=204218&status=done&style=none&taskId=u36fd0e3a-eda4-44e0-878e-1402dcda3ed&title=&width=991.2)
通过图中的入门程序可知，所有可被AOP控制的方法都是连接点，那在spring提供的joinpoint当中就封装了连接点方法在执行时的相关信息，
通知就是抽取出来的重复的逻辑，那么这些通知应用到哪些方法上由切入点pointCut来决定，
切入点就是被AOP实际控制的方法，通过切入点表达式来描述切入点，
通知与切入点结合就是一个切面，来决定什么通知，应用在什么地方上。
### AOP执行流程
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1692780691710-758e9670-8ca3-49b5-80b0-3a49ca608011.png#averageHue=%23faf6de&clientId=u86a40beb-38d6-4&from=paste&height=627&id=u2c95e419&originHeight=784&originWidth=1558&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=594933&status=done&style=none&taskId=uc14350c6-df07-47d5-b479-e0bd0d97d1e&title=&width=1246.4)
上图对一个方法进行改写：
:::tips

1. AOP执行流程中，在程序运行的时候会自动的基于动态代理技术为这个目标对象生成一个对应的代理对象，
2. 在这个代理对象当中就会对目标对象的原始方法进行功能增强
3. 这个例子的增强逻辑就是我们所定义的通知，在b代理对象的方法中就对目标对象的方法进行了增强功能。
4. 最终在程序注入的时候就不再是这个目标对象，注入的是代理对象，相应的在调用方法的时候调用的就是代理对象当中的方法。
:::
### AOP进阶
#### 通知类型
:::tips

1. @Around:环绕通知，此注解标注的通知方法在目标方法前、后都被执行
2. @Before:前置通知，此注解标注的通知方法在目标方法前被执行
3. @After:后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行
4. @AfterReturning:返回后通知，此注解标注的通知方法在目标方法后被执行、有异常不会执行
5. @AfterThrwoing:异常后通知，此注解标注的通知方法在发生异常后执行
:::
注意：
:::tips

- @Around环绕通知需要自己调用ProceedingJoinPoint.proceed()来让原始方法执行，其它通知不需要考虑目标方法执行
- @Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值。
:::
#### 切入点表达式
**第一种：execution**
语法：
:::tips
execution(访问修饰符?  返回值  包名.类名.?方法名(方法参数) throws 异常?)
:::
注意：
:::tips
其中带 ? 的表示可以省略的部分

- 访问修饰符：可省略（比如: public、protected）
- 包名.类名： 可省略
- throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）
:::
可以使用通配符描述切入点

1. ***** ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分
```java
execution(* com.*.service.*.update*(*))
```

2. **.. **：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数
```java
execution(* com.itheima..DeptService.*(..))
```
**第二种：@annotation **

- 用于匹配标识有特定注解的方法。
```java
@annotation(com.itheima.anno.Log)
```
使用方法：

1. 先定义一个注解类MyLog

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1692863663414-2c8ebe73-220b-4c0e-ad72-38edaa640a6c.png#averageHue=%23907f3f&clientId=u86a40beb-38d6-4&from=paste&height=241&id=u8265b445&originHeight=301&originWidth=770&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=56849&status=done&style=none&taskId=uf939417a-30d4-462c-9ecc-3a2744610ba&title=&width=616)

2. 在通知里定义切入点

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1692863834476-7fa9a394-1790-41cb-bdbb-2318c866fb7e.png#averageHue=%238d783d&clientId=u86a40beb-38d6-4&from=paste&height=216&id=udc5906c5&originHeight=270&originWidth=758&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40653&status=done&style=none&taskId=uab9eff69-b193-4a4d-9195-020f5988f6d&title=&width=606.4)

3. 在需要使用的方法上加上对应名字的注解

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1692863757489-73ed6fd6-8974-4c91-b61d-c1d12759ccca.png#averageHue=%232e2c2b&clientId=u86a40beb-38d6-4&from=paste&height=250&id=u2c87dc56&originHeight=313&originWidth=646&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32398&status=done&style=none&taskId=u5dd70b50-3861-4e78-930b-e465b942a0f&title=&width=516.8)
这样就可直接匹配到加了注解的方法了。
#### 连接点
在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等
注意：对于 @Around 通知，获取连接点信息只能使用  ProceedingJoinPoint
```java
@Around("execution(* com.itheima.service.DeptService.*(..))")
public Object around(ProceedingJoinPoint joinPoint) throws Throwable {}

@Before("execution(* com.itheima.service.DeptService.*(..))")
public void before(JoinPoint joinPoint) {}
```
## 配置优先级
按优先级排序：
:::tips
application.yaml（忽略）
application.yml
application.properties
java系统属性（-Dxxx=xxx）
命令行参数（--xxx=xxx）
:::
## Bean管理
### 获取bean
默认情况下，Springboot项目启动时，会把bean都创建好放在IOC容器中，如果想要主动获取这些bean，可以通过如下方式, 使用applicationContext.getBean()方法：
:::tips

1. 根据name获取bean
2. 根据类型获取bean
3. 根据bean的名称及类型获取
:::
```java
 @Autowired
 private ApplicationContext applicationContext; //IOC容器对象

    //获取bean对象
    @Test
    public void testGetBean(){
        //根据bean的名称获取
        DeptController bean1 = (DeptController) applicationContext.getBean("deptController");
        System.out.println(bean1);

        //根据bean的类型获取
        DeptController bean2 = applicationContext.getBean(DeptController.class);
        System.out.println(bean2);

        //根据bean的名称 及 类型获取
        DeptController bean3 = applicationContext.getBean("deptController", DeptController.class);
        System.out.println(bean3);
    }
```
### bean的作用域
spring支持五种作用域，这里我需要记两种：
:::tips
singleton：容器内同 名称 的 bean 只有一个实例（单例）（默认）
prototype：每次使用该 bean 时会创建新的实例（非单例）
:::
可以通过 @Scope 注解来进行配置作用域：
```java
@Scope("prototype")
@RestController
@RequestMapping("/depts")
public class DeptController {
}
```
注意：
:::tips

- 默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化（延迟到第一次使用时）。
- prototype的bean，每一次使用该bean的时候都会创建一个新的实例。
- 实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。
:::
### 第三方bean

- **说明：**如果要管理的bean对象来自于第三方（不是自定义的），是无法用 @Component 及衍生注解声明bean的，就需要用到 @Bean
- **用法：**若要管理的第三方bean对象，建议对这些bean进行集中分类配置，可以通过 @Configuration 注解声明一个配置类。
```java
@Configuration //配置类
public class CommonConfig {

    //声明第三方bean
    @Bean //将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean
          //通过@Bean注解的name/value属性指定bean名称, 如果未指定, 默认是方法名
    public SAXReader reader(DeptService deptService){
        System.out.println(deptService);
        return new SAXReader();
    }

}
```

- **注意：**
:::tips

- 通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名。
- 如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。
:::
# springBoot原理
springBoot简化了Spring Framework框架的开发，主要是因为springboot底层提供的起步依赖和自动配置功能。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1692956270871-bc7707b1-add7-4714-84e6-d57db8c9c09a.png#averageHue=%23fcf9f8&clientId=uf494617b-b0ce-4&from=paste&height=481&id=u33e21ec8&originHeight=601&originWidth=1492&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=221539&status=done&style=none&taskId=u5d25e22d-5142-4787-b187-6c9297ca6bc&title=&width=1194)
## 起步依赖
### 作用
:::tips
Spring框架的依赖配置比较繁琐，创建一个spring项目需要的依赖多且存在版本匹配问题，使用springboot可以解决这个问题。
使用Springboot进行Web项目的开发,我们只需引入一个依赖：springboot-start-web。
如果要进行AOP程序的开发，我们只需引入一个Springboot-starter-aop依赖就可以了。
:::
### 原理
:::tips
Springboot起步依赖的原理就是**maven的依赖传递(**如果A依赖了B, B依赖了C, C依赖了D，那么引入A之后BCD这三项依赖也就引入进来了)。
:::
## 自动配置
SpringBoot的自动配置就是当spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。
###  实现自动配置
**方案一：@ComponentScan 组件扫描**
在启动类上加@ComponentScan注解，引入第三方bean对象，每引入一个第三方bean就要加个扫描包，太繁琐了
```java
@ComponentScan({"com.example","com.itheima","com.alibaba","com.google",
                "org.springframework","org.mybatis",...}
@SpringBootApplication
public class SpringbootWebConfig2Application {
}
```
**方案二：@Import 导入**
使用@Import导入的类会被Spring加载到IOC容器中，导入形式主要有以下几种：

1. 导入 普通类
2. 导入 配置类
3. 导入 ImportSelector 接口实现类（主要用这种）

在配置类上加：
```java
//@Import({TokenParser.class}) //1.导入普通类，交给IOC容器管理，成为容器的Bean对象
//@Import({HeaderConfig.class}) //2.导入配置类，交给IOC
//@Import({MyImportSelector.class}) //3.导入ImportSelector接口实现类
@EnableHeaderConfig //由第三方bean定义好的注解类，里面封装了@Import
@SpringBootApplication
public class SpringbootWebConfig2Application {
```
### 源码解析
**@springBootApplication详解**
该注解由三个部分组成：

- @SpringBootConfiguration:该注解与@Configuration注解作用相同，用来声明当前也是一个配置类
- @ComponentScan:组件扫描，默认扫描当前引导类所在包及其子包。
- @EnableAutoConfiguration: SpringBoot实现自动化配置的核心注解。

**@Conditional类注解详解**
作用: 按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring lOC容器中。位置:方法、类

- @Conditional本身是一个父注解，派生出大量的子注解:
- @ConditionalOnClass:判断环境中是否有对应字节码文件，才注册bean到IOG容器。
```java
@Bean
//环境中存在指定的这个类，才会将该bean加入IOC容器中（有Jwts的依赖，相应的有这个类）
@ConditionalOnClass(name = "io.jsonwebtoken.Jwts")
public HeaderParser headerParser(){
    return new HeaderParser();
}
```

- @ConditionalOnMissingBean:判断环境中没有对应的bean(类型或名称），才注册bean到IOC容器.
```java
    @Bean
    //不存在该类型的bean,才会将该bean加入IOC容器中
    @ConditionalOnMissingBean
    public HeaderParser headerParser(){
        return new HeaderParser();
    }
```

- @ConditionalOnProperty:判断配置文件中有对应属性和值，才注册bean到IOC容器。
```java
    @Bean
    //配置文件中存在指定的属性与值，才会将该bean加入IOC容器中
    //（即application.yml配置文件中有name: wmy这项配置才行）
    @ConditionalOnProperty(name = "name", havingValue = "wmy")
    public HeaderParser headerParser(){
        return new HeaderParser();
    }
```
