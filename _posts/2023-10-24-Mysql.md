![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689324041578-4e5ce4f9-89bf-4aa0-bfd3-1941d888192d.png#averageHue=%23f8f8f8&clientId=udd0843e6-cc84-4&from=paste&height=281&id=u5a2e8d6d&originHeight=351&originWidth=1463&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=146732&status=done&style=none&taskId=u1d41b311-06f0-4de1-b6e3-894588ee44d&title=&width=1170.4)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689324599196-2bcad4fd-440b-4c0f-bd7c-8c393f57bad5.png#averageHue=%23fefefe&clientId=udd0843e6-cc84-4&from=paste&height=346&id=u36dc1359&originHeight=432&originWidth=868&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=91977&status=done&style=none&taskId=u2cf5157b-3781-4de6-9342-163dc8b56e1&title=&width=694.4)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689324628562-912b00b0-864c-42b2-a887-2889427e0657.png#averageHue=%23f7f6f6&clientId=udd0843e6-cc84-4&from=paste&height=434&id=u79199e6b&originHeight=542&originWidth=1374&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=183774&status=done&style=none&taskId=ub03255f7-371d-4d2e-9b06-add47cd3ba9&title=&width=1099.2)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689324721606-91eb1263-6d61-49b1-84ef-f91bc1341c74.png#averageHue=%23f5eee5&clientId=udd0843e6-cc84-4&from=paste&height=693&id=u4931507a&originHeight=866&originWidth=1341&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=371688&status=done&style=none&taskId=u5e0f9e25-442d-45e1-aec3-0353922d91f&title=&width=1072.8)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689325048260-ca9ea470-24d3-440c-afc3-345ce056f38d.png#averageHue=%23fcfbf4&clientId=udd0843e6-cc84-4&from=paste&height=529&id=u6fc15e9e&originHeight=661&originWidth=1407&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=228431&status=done&style=none&taskId=ue969e14b-1e50-4e30-9cbf-1832fbb76c8&title=&width=1125.6)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689325244355-d4907e61-90d6-4d0c-a21c-0033c5c98c1c.png#averageHue=%23fdfbf1&clientId=udd0843e6-cc84-4&from=paste&height=358&id=u9ea7fc00&originHeight=448&originWidth=1399&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=117280&status=done&style=none&taskId=uc862c7da-d14b-495c-b0e4-d49e8764acc&title=&width=1119.2)
# 数据操作
## 添加

1. **给指定列添加**数据: insert into 表名（列名1，列名2，...）values(值1，值2);
```sql
insert into stu(id,name) values(1,'张三'); 
```

2. **给所有列添加**数据，列名的列表可以省略
```sql
insert into stu values(2,'李四','男','','');
```

3. **多行插入 **
```sql
insert into stu values (3,'my'),(4,'yy');
```

4. **插入时间**
:::tips
比如字段类型为时间类型，标准插入方式为：
‘YYYY-MM-DD HH:mm:ss’
‘2022-07-03 12:00:00’
比较时间，按照> = < 即可。
:::
## 查询
### 基础查询
#### **全列查询**
最基础的操作，但在实际开发中也很危险，如果数据量较大，进行全列查询将会大量消耗系统资源，有可能导致宕机。
```sql
select*from 表名;
```
#### **指定列查询**
这种相对于全列查询要高效很多，在查询时会显示告诉数据库要查询哪些列，数据库就会有针对性的返回数据了。
```sql
select 列名，列名...... from 表名;
```
#### **查询字段为表达式**
在查询的同时进行一些运算操作（列和列之间）
```sql
--例如，期望查询结果中的语文成绩比真实成绩高十分：
select name,Chinese + 10 from exam_reuslt; 

--查询每个同学的总分：
select name, chinese + math + english from exam_result;
```
#### **查询字段指定别名**
通过指定别名的方式防止得到的临时表列名太乱。
```sql
select name,chinese+math+english as tatal from exam_result;
```
#### **针对查询结果去重**
针对查询结果，把重复的记录抹去.
```sql
--把math这一列里所有重复的去掉
select distinct math from exam_result;
```
如果是针对多个列进行去重，只有这多个列的值都相同时才会被视为重复
#### **针对查询结果排序**
```sql
select 列名..... from 表明 order by 列名 asc/desc;

--针对数学成绩进行升序排序 asc为升序（默认为升序可以不写），desc为降序
select *from exam_result order by math asc,
```
**注意：**
1 数据库记录中带NULL值的将被视为最小（在排序中会被视为最小值）
2 排序也可依据别名或表达式来进行排序。
```sql
select name,chinese+math+english as total from exam_result order by total;
```
3 指定多个列排序时，先根据第一个列进行排序，如果第一个列的值相同再按第二个列的结果排序
```sql
--如下先按照数学排序，数学相同再按语文排序。
select name,chinese,math from exam_result order by math,chinese;
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689351377609-16974877-89df-45a6-82d0-c7947bb1c87b.png#averageHue=%232f3b49&clientId=ub2326c12-d429-4&from=paste&height=278&id=u6d5dbb98&originHeight=348&originWidth=472&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=89965&status=done&style=none&taskId=u751348b4-5f08-4212-aa33-1ee34d95fac&title=&width=377.6)
### 条件查询
#### 一般条件
在select子句后面加上where筛选条件，查询结果会把满足条件的保留，不满足的过滤掉。
```sql
select 列名 from 表名 where 条件;
```
比较运算符：

| 运算符 | 说明 |
| --- | --- |
| >, >=, <, <=	 | 大于，大于等于，小于，小于等于 |
| = | 等于，NULL 不安全，例如 NULL = NULL 的结果是 NULL |
| <=> | 等于，NULL 安全，例如 NULL <=> NULL 的结果是 TRUE(1) |
| !=, <> | 不等于 |
| BETWEEN a0 AND a1 | 范围匹配，[a0, a1]，如果 a0 <= value <= a1，返回 TRUE(1) |
| IN (option, …)	 | 如果是 option 中的任意一个，返回 TRUE(1) |
| IS NULL | 是 NULL |
| IS NOT NULL | 不是 NULL |
| LIKE	模糊匹配。 | % 表示任意多个（包括 0 个）任意字符；_ 表示任意一个字符 |

逻辑运算符：

| 运算符 | 说明 |
| --- | --- |
| AND | 多个条件必须都为 TRUE(1)，结果才是 TRUE(1) |
| OR | 任意一个条件为 TRUE(1), 结果为 TRUE(1) |
| NOT	 | 条件为 TRUE(1)，结果为 FALSE(0) |

注意：
1 WHERE条件可以使用表达式，但不能使用别名。
2 AND的优先级高于OR，在同时使用时，需要使用小括号()包裹优先执行的部分
```sql
select * from exam_result where chinese > 80 or math > 70 and english >70;
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689352174719-fd73555d-3570-4b8b-a6ff-ce97731e5c7b.png#averageHue=%2342484b&clientId=ub2326c12-d429-4&from=paste&height=162&id=u3fbcf6d1&originHeight=203&originWidth=616&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=134649&status=done&style=none&taskId=ud6c01518-c169-4b38-a78c-25519fe5ce6&title=&width=492.8)
```sql
select * from exam_result where (chinese>80 or math>70) and english >70;
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689352243939-a21575d6-7039-475b-9985-6ce69d65b98b.png#averageHue=%23493d34&clientId=ub2326c12-d429-4&from=paste&height=101&id=u46325806&originHeight=126&originWidth=595&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=108321&status=done&style=none&taskId=u07f50107-1f98-4d0c-9888-3db8026a503&title=&width=476)
#### between...and... 
在编程领域里，大部分区间都是左闭右开，注意在SQL中是左右都闭合的区间
```sql
--查询语文成绩在 [80, 90] 分的同学及语文成绩
select * from exam_result where chinese between 80 and 90;
```
#### in
```sql
--查询数学成绩是 58 或者 59 或者 98 或者 99 分的同学及数学成绩
select * from exam_result where math in (58,59,98,99);
```
#### 模糊查询：LIKE
% 匹配任意多个（包括 0 个）字符
_ 匹配严格的一个任意字符
```sql
select * from exam_result where name like '孙%';
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689352791548-edc63ea6-ff99-4189-8eb0-e7d48317ea93.png#averageHue=%23393c56&clientId=ub2326c12-d429-4&from=paste&height=120&id=u03cd809b&originHeight=150&originWidth=805&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=111363&status=done&style=none&taskId=u4acc2879-4ea7-48ad-baf0-76c9412637d&title=&width=644)
```sql
select * from exam_result where name like '孙_';
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689352828245-494d01bf-e7de-48c6-a5e6-85b591c238d0.png#averageHue=%233a3d59&clientId=ub2326c12-d429-4&from=paste&height=63&id=ud087c844&originHeight=79&originWidth=762&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=57532&status=done&style=none&taskId=u8f93d15d-6ffd-42a8-9b08-c214c3bdcf0&title=&width=609.6)
#### NULL 的查询
有<=>、is null这两种方式来判别是否为null
```sql
select * from exam_result where chinese <=> null;

select * from exam_result where chinese is null;
```
### 分组查询
#### **聚合函数**
将一列数据作为一个整体，进行纵向计算
函数分类：

| 函数名 | 功能 |
| --- | --- |
| count() | 统计数量 |
| max() | 最大值 |
| min() | 最小值 |
| sum() | 求和 |
| avg() | 平均值 |

语法：
```sql
select 聚合函数名（列名）from 表;
```
注意：
null值不参与所有聚合函数计算
具体用法：

1. 统计班级有多少人数
```sql
select count(id) from stu; --count统计的列名不能为null
```

2. 查询数学成绩的最高分/最低分/和/平均值
```sql
seclect max(math) from stu; --换函数名即可
```

3. 如果所查询列有null值，是不参与聚合函数运算的

比如查英语成绩的最低分，有一个null值，查出来的是另一个有数值的值，而不是null值最小
#### 分组函数
语法：
```sql
select 字段列表 from 表名 [where 分组条件限定] group by 分子字段名 
                                             [having 分组后条件过滤]
```
注意：
:::tips
分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义
:::
where和having的区别：
:::tips
执行时机不一样：where是分组之前进行限定，不满足where条件的不参与分组，而                                      having是分组后对结果进行过滤
可判断的条件不一样：where不能对聚合函数进行判定，having可以
:::
执行顺序：
:::tips
where>聚合函数>having
:::
具体用法：

1. 查询男同学和女同学各自的数学平均分
```sql
select sex,avg(math) from stu group by sex;
```

2. 查询男同学和女同学各自的数学平均分以及各自人数
```sql
select sex,avg(math),count(*) from stu group by sex;
```

3. 查询男同学和女同学各自的数学平均分以及各自人数，要求：分数低于70的不参与分组
```sql
select sex,avg(math),count(*) from stu where math>70 group by sex;
```

4. 查询男同学和女同学各自的数学平均分以及各自人数，要求：分数低于70的不参与分组,分组之后人数大于2
```sql
select sex,avg(math),count(*) from stu where math>70 
                              group by sex having count(*) > 2;
```
### 分页查询
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689405997676-e68c6874-bc1c-48b5-a804-53c13ccf536d.png#averageHue=%23f4f6f5&clientId=ub2326c12-d429-4&from=paste&id=uc68613e5&originHeight=70&originWidth=634&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=7597&status=done&style=none&taskId=u3b1f684a-05cb-4ee3-8514-56df1473f76&title=)
如果查询到的结果数较多，我们就需要按照上图的方式来进行分页展示。在sql中利用limit来进行分页查询，
语法：
```sql
-- 起始下标为 0
-- 从 0 开始，筛选 n 条结果
SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT n;
-- 从 s 开始，筛选 n 条结果
SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT s, n;
-- 从 s 开始，筛选 n 条结果，比第二种用法更明确，建议使用
SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT n OFFSET s;
```
计算公式：
:::tips
起始索引=（当前页码-1）*每页显示的条数
:::
## 修改
语法：
```sql
update 表名 set 列名=值（或表达式），列名=值（或表达式）..... where 条件;
```
用法：
```sql
--将孙悟空同学的数学成绩变更为 80 分
update exam_result set math =80 where name='孙悟空';
```
## 删除
语法：
```sql
delete from 表名 where 条件 [ORDER BY ...] [LIMIT ...];
```
# 约束
## 约束类型
| 约束名称 | 描述 | 关键字 |
| --- | --- | --- |
| 非空约束 | 保证列中所有数据不能有null值 | NOT NULL |
| 唯一约束 | 保证列中所有数据各不相同 | UNIQUE |
| 主键约束 | 主键是一行数据的唯一标识，要求非空且唯一 | PRIMARY KEY |
| 检查约束 | 保证列中的值满足某一条件 | CHECK |
| 默认约束 | 保存数据时，未指定值则采用默认值 | DEFAULT |
| 外键约束 | 外键用来让两个表的数据之间建立连接，保证数据的一致性和完整性 | FOREIGN KEY |

## 案例
```sql
CREATE table emp (
    id int PRIMARY KEY auto increment, -- 员工id，主键且自增长
		ename VARCHAR(50) not null UNIQUE, -- 员工姓名，非空
		joindate DATE NOT NULL, -- 入职日期，非空
		salary DOUBLE(7,2) NOT NULL, -- 工资，非空
		bonus DOUBLE(7,2) DEFAULT 0 -- 奖金，如果没有默认为0 
);
```

1. 主键约束：非空且唯一
```sql
insert into emp(id,ename,joindate,salary,bonus) 
                     -- id不能为空，且不能重复，这条语句错误 
                 values(null,'张三','2002-10-10',8000,5000);
```

2. 默认约束
```sql
insert into emp(id,ename,joindate,salary) 
                     -- 最后bonus这列没指定值，默认0
                 values(3,'wmy','2002-09-21',8000)
```

4. 自动增长（条件：当列是自动类型并且唯一约束）
```sql
insert into emp(id,ename,joindate,salary,bonus) values('张三','2002-10-10',8000,null);
insert into emp(id,ename,joindate,salary,bonus) values(null,'wmy','2002-10-22',8000,null);
insert into emp(id,ename,joindate,salary,bonus) values(null,'wmy2','2002-10-22',8000,null);
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689411014232-91906535-9d29-436e-9068-6efae077ad02.png#averageHue=%23e2e0dd&clientId=ub2326c12-d429-4&from=paste&height=118&id=u301de6a6&originHeight=148&originWidth=453&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=60342&status=done&style=none&taskId=u7a10ab39-bf06-4457-9b36-7df3f90d629&title=&width=362.4)

5. **外键约束**
- 概念：
:::tips
外键用来让两个表的数据之间建立连接，保证数据的一致性和完整性
:::

- 语法：

（1）添加约束
```sql
-- 第一种方式：创建表时添加外键约束
cerate table 表名(
  列名 数据类型，
  ...
  constraint 外键名称 foreign key(外键列名) references 主表(主表列名)
);

-- 第二种方式：建完表后添加外键约束
alter table 表名 add constraint 外键名称 foreign key(外键字段名称) 
                                        references 主键名称(主表列名称)；
```
（2）删除约束
```sql
alter table 表名 drop foreign key 外键名称;
```
案例：
从表：员工表        主表：部门表
```sql
-- 部门表
CREATE TABLE dept(
  id int primary key auto_increment,
	dept_name VARCHAR(20),
	addr VARCHAR(20)
);

-- 员工表
CREATE TABLE emp(
  id int primary key auto_increment,
	name varchar(20),
	age int,
	dept_id int,
	-- 添加外键dep_id,关联dept表的id主键
	CONSTRAINT fk_emp_dept FOREIGN KEY(dept_id) REFERENCES    dept(id)
);

```
这两个表之间建立了连接：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689413450398-31d2dc87-b905-4705-a783-afed1e166ad9.png#averageHue=%23f9f9f9&clientId=ub2326c12-d429-4&from=paste&height=162&id=MT0zZ&originHeight=202&originWidth=527&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13737&status=done&style=none&taskId=u3583107b-81d8-43af-b37f-7d660f64c86&title=&width=421.6)
因为两个表建立了连接，若直接删除dept表的一行是不行的，需要先把emp表中外键关联的都删掉。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689413141041-9483c8cd-8412-4249-8e02-47f8d46b1ac1.png#averageHue=%23edebea&clientId=ub2326c12-d429-4&from=paste&height=102&id=u49bd6b71&originHeight=128&originWidth=1023&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12946&status=done&style=none&taskId=u43b1dec7-cf2b-40ee-b6bf-d3fb68a8617&title=&width=818.4)

- 拓展：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689435706370-5fad6159-f77d-4722-b425-c40c344f708c.png#averageHue=%23ebdac9&clientId=ueed077c2-6af1-4&from=paste&height=358&id=UaoKM&originHeight=448&originWidth=1544&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=281473&status=done&style=none&taskId=uf3b71ed5-81a9-4bea-a3f2-974a5ea8c03&title=&width=1235.2)
# 数据库设计
## 多表设计
### 一对多

- 一对多（多对一）

       如：部门表和员工表，一个部门对应多个员工，一个员工对应多个部门

- 实现方式：在多的一方添加字段，指向一的一方的主键
### 一对一

- 用户与用户信息表
- 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其它字段放在另一张表中，以提升操作效率
- 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的
### 多对多

- 一个学生可以选择多门课程，一门课程也可被多个学生选择
- 实现：建立第三张中间表，中间表包含两个外键，分别关联两方主键
- 如下图三个表关系：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689480759584-2d3ef564-92c9-4e12-b9ef-a283554c69f4.png#averageHue=%23faf7f6&clientId=uaf9d9eba-0927-4&from=paste&height=241&id=u34f64755&originHeight=301&originWidth=650&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=73260&status=done&style=none&taskId=u67463c19-c69d-4dd7-a005-69f72c37b9b&title=&width=520)
### 案例理解
如下图: 

- 分类表与菜品表之间是一对多关系，一个菜品类对应多个菜品
- 分类表与套餐表之间也是一对多关系，一个菜品类可有多个套餐
- 套餐表与菜品表是多对多关系，一个套餐里有多个菜，一个菜品也有多个套餐，建立中间表，关联这两个表的主键

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689485353374-a103dbd7-8674-49f3-8478-cc63068f5124.png#averageHue=%23f7f7f7&clientId=uaf9d9eba-0927-4&from=paste&height=462&id=u2693d373&originHeight=578&originWidth=825&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=34599&status=done&style=none&taskId=ufce2f8d2-0259-4473-ac26-6c720bcc78c&title=&width=660)
# 多表查询
## 连接查询
### 内连接

- 隐藏式内连接：
```sql
select 字段列表 from 表1,表2 where 条件;

-- 1.查询员工的姓名，及所属的部门名称（隐藏内连接实现）
select e.name,d.name from tb_emp e,tb_dept d where e.dept_id = d.id;
```

- 显式内连接：
```sql
select 字段列表 from 表1 join 表2 on 条件;

-- 2.查询员工的姓名，及所属的部门名称（显示内连接实现）
select e.name,d.name from tb_emp e join tb_dept d on e.dept_id = d.id;
```

- 注意：内连接不能查询出没有分配部门的员工信息。
### 外连接

- 左外连接：查询左表所有数据（包括两张表交集部分数据）
```sql
-- 1.查询员工的姓名，及所属的部门名称（左外连接实现）
select e.name, d.name -- 员工和部门姓名
from tb_emp e
         left join tb_dept d on e.dept_id = d.id; 
-- 会查询出左边emp表的所有员工信息，即使没有与右边dept表关联
```
查询结果：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689495251445-c4a63582-6251-4aee-9ef6-27c37004cab0.png#averageHue=%23837054&clientId=uaf9d9eba-0927-4&from=paste&height=138&id=uab21ab74&originHeight=173&originWidth=361&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13160&status=done&style=none&taskId=u706c8500-2b43-4104-9c08-eed25618149&title=&width=288.8)

- 右外连接：查询右表所有数据（包括两张表交集部分数据）
```sql
-- 2.查询员工的姓名，及所属的部门名称（右外连接实现）
select e.name, d.name -- 员工和部门姓名
from tb_emp e
         right join tb_dept d on e.dept_id = d.id; 
-- 会查询出右边dept的所有部门名称，即使未与左边emp表的员工关联
```
查询结果：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689495450001-e0f6bb6a-95a8-4880-b414-db24aee8c2e9.png#averageHue=%237b674e&clientId=uaf9d9eba-0927-4&from=paste&height=134&id=u33ffc48c&originHeight=168&originWidth=389&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=14301&status=done&style=none&taskId=ucdc63218-037c-4d72-b89b-c5a91d42e84&title=&width=311.2)
## 子查询
### 标量子查询
子查询返回的结果是单个值（数字、字符串、日期等）
用法：
```sql
-- 标量子查询
-- 1.查询“教育部”的所有员工信息
-- 1.1 查询“教育部”的部门ID  1.2 再查询该部门ID下的员工信息
select *
from tb_emp
where dept_id = (select id from tb_dept where name = '教育部');
```
### 列子查询
子查询返回的结果为一列（可以说多行）
常用操作符：in、not in
用法：
```sql
-- 列子查询
-- 1.查询“教育部”和“教学部”的所有员工信息
-- 1.1 查询“教育部”和“教学部”的部门ID   1.2 根据部门ID，查询该部门下的员工信息
select *
from tb_emp
where dept_id in 
        (select id from tb_dept where tb_dept.name = '教育部' or tb_dept.name = '教学部');
```
### 行子查询
子查询返回的结果是一行（可以说多列）
常用操作符：=、<>、in、not in
用法：
```sql
-- 行子查询
-- 1.查询和‘wmy’的入职日期和职位都相同的员工信息
-- 1.1 查询‘wmy’的入职日期和职位 1.2 查询与其入职日期和职位都相同的员工信息
select *
from tb_emp
where entryDate = (select entryDate from tb_emp where name = 'wmy')
  and job = (select job from tb_emp where name = 'wmy');
-- 简化写法
select *
from tb_emp
where (entryDate, job) = (select entryDate, job from tb_emp where name = 'wmy');
```
### 表子查询
子查询返回的结果是多行多列，常作为临时表
常用操作符：in
用法：
```sql
-- 表子查询
-- 1.查询入职日期是“2002-10-10”之后的员工信息，及其部门名称
-- 1.1 查询入职日期是“2002-10-10”之后的员工信息 1.2 查询这部分员工信息和部门名称
select e.*, d.name
from (select * from tb_emp where entryDate > '2002-10-10') e,
     tb_dept d
where e.dept_id = d.id;
```
# 事务
## 事务介绍
事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689505841071-0af0c6ca-933c-45e2-a24d-9e0503ff84cb.png#averageHue=%23f9f5f5&clientId=uaf9d9eba-0927-4&from=paste&height=605&id=u456534a4&originHeight=756&originWidth=1579&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=238463&status=done&style=none&taskId=uf4c22309-e6c5-42e8-a1ce-70154e308d8&title=&width=1263.2)
## 事务操作
start transation / begin;
commit;
rollback;
## 四大特性
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689506580962-b655a281-6f08-4671-8cbb-bcd602e1448f.png#averageHue=%23e5e5e3&clientId=uaf9d9eba-0927-4&from=paste&height=342&id=u1b23b2e5&originHeight=427&originWidth=1037&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=188648&status=done&style=none&taskId=u30cb0531-324d-402a-8cd6-169eaa078df&title=&width=829.6)
# 索引
## 介绍
索引是帮助数据库高效获取数据的数据结构
优缺点：
:::tips
优点：

- 提高数据查询的效率，降低数据库的IO成本。
- 通过索引列对数据进行排序，降低数据库排序的成本，降低CPU消耗。

缺点：

- 索引会占用存储空间。
- 索引大大提高了查询效率，同时却也降低了增删改的效率。
:::
## 结构

1. mysql索引采用B+Tree结构

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689563375661-e23dccac-844c-4152-bb73-24d4d6b01d76.png#averageHue=%23f9f9f8&clientId=uaf9d9eba-0927-4&from=paste&id=u94d535a1&originHeight=456&originWidth=1274&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=53658&status=done&style=none&taskId=ua956ad21-604b-4ded-a3f8-e7bf53e04d7&title=)

2. B+树有以下的特性：
:::tips

- 非叶子节点只存放索引项，叶子节点既存放索引项，也存放具体的数据。
- 叶子节点会存放当前所有的索引项，就是说，可以与父节点的索引项重复。
- 叶子节点通过指针相连，形成有序的双向链表结构，便于数据的排序及区间范围查询。
:::

3. 各类数据结构的比较介绍：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1689563294876-fbb82c99-f36c-40d5-a118-f7a794ac5b21.png#averageHue=%23f4f3f2&clientId=uaf9d9eba-0927-4&from=paste&height=378&id=u395aa43b&originHeight=472&originWidth=1198&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=76389&status=done&style=none&taskId=ud44b5aff-5436-4e83-b619-8421336fb64&title=&width=958.4)
## 语法
创建索引
create [unique] index 索引名 on 表名（字段名,...）;
查看索引
show index from 表名;
删除索引
drop index 索引名 on 表名;
```sql
-- 创建索引：为tb_emp的name字段建立一个索引
create index idx_emp_name on tb_emp(name);

-- 查看索引
show index from tb_emp;

-- 删除索引
drop index idx_emp_name on tb_emp;
```
注意：

- 主键字段，在建表时，会自动创建主键索引。
- 添加唯一约束时，数据库实际上会添加唯一索引。
# springboot下的mybatis
## mybatis基础操作
### 删除
```java
@Mapper
    public interface EmpMapper {
    //根据ID删除信息
    @Delete("delete from emp where id = #{id}")
    public void delete(Integer id);
    }
```
```java
@SpringBootTest
class SpringbootMybatis02ApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void testDelete(){
        empMapper.delete(16);
    }
}
```
注意：
:::tips
如果mapper接口方法形参只有一个普通类型的参数，#{…} 里面的属性名可以随便写，如：#{id}、#{value}。
:::
### 预编译SQL
优势：
:::tips
性能更高 ，更安全(防止SQL注入)
:::
SQL注入了解：
:::tips
SQL注入是通过操作输入的数据来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。
:::
参数占位符：
#{...}
:::tips
执行SQL时，会将#{…}替换为?，生成预编译SQL，会自动设置参数值。
使用时机：参数传递，都使用#{…}
:::
${...}
:::tips
拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题。
使用时机：如果对表名、列表进行动态设置时使用
:::
### 新增
```java
//新增员工
    @Options(useGeneratedKeys = true, keyProperty = "id")
    @Insert("insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) " +
            "values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime},#{updateTime})")
    public void insert(Emp emp);
```
```java
    @Test
    public void testInsert(){
        Emp emp = new Emp();
        emp.setUsername("Tom2");
        emp.setName("汤姆2");
        emp.setImage("1.jpg");
        emp.setGender((short)1);
        emp.setJob((short)1);
        emp.setEntrydate(LocalDate.of(2000,1,1));
        emp.setCreateTime(LocalDateTime.now());
        emp.setUpdateTime(LocalDateTime.now());
        emp.setDeptId(1);

        empMapper.insert(emp);
        //在数据添加成功后，需要获取插入数据库数据的主键。
        System.out.println(emp.getId());
    }

```
### 更新
```java
//更新员工
    @Update("update emp set username=#{username},name=#{name},gender=#{gender},image=#{image}," +
            "job=#{job},entrydate=#{entrydate},dept_id=#{deptId},update_time=#{updateTime} where id=#{id}")
    public void update(Emp emp);
```
```java
@Test
    public void testUpdate(){
        Emp emp = new Emp();
        emp.setId(18);
        emp.setUsername("Tom3");
        emp.setName("汤姆3");
        emp.setImage("1.jpg");
        emp.setGender((short)1);
        emp.setJob((short)1);
        emp.setEntrydate(LocalDate.of(2000,1,1));
        emp.setUpdateTime(LocalDateTime.now());
        emp.setDeptId(1);

        empMapper.update(emp);
    }
```
### 查询
```java
//根据ID查询员工
    @Select("select * from emp where id = #{id}")
    public Emp selectById(Integer id);
```
用这种查询方式会造成mybatis的数据封装问题
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1690092636389-ac652cc4-6e48-4d2b-9557-29e2370c0ccb.png#averageHue=%23332f2d&clientId=u337fbe84-3a6b-4&from=paste&height=108&id=u91a0f8d0&originHeight=135&originWidth=1281&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=35184&status=done&style=none&taskId=u6e235c3d-4a57-4f96-b63f-a5ee62256bf&title=&width=1024.8)
数据封装：
:::tips
实体类属性名 和 数据库表查询返回的字段名一致，mybatis会自动封装。
如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装。
:::
解决：

1. 给字段起别名，让别名与属性名一致
```java
//方案一：给字段起别名，让别名与属性名一致
    @Select("select id, username, password, name, gender, image, job, entrydate, " +
            "dept_id deptId, create_time createTime, update_time updateTime from emp where id = #{id}")
    public Emp selectById(Integer id);
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1690092805282-e855664d-9302-4cf7-bd53-fed40fe3c057.png#averageHue=%23302827&clientId=u337fbe84-3a6b-4&from=paste&height=79&id=u81729d63&originHeight=112&originWidth=1551&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29900&status=done&style=none&taskId=u5d9f81ac-8da4-4a75-a535-72d94067194&title=&width=1094)

2. 通过@Results、@Result注解手动映射封装，只对字段名和属性名不一致的进行手动映射封装
```java
// 方案二：通过@Results、@Result注解手动映射封装
    @Results({
            @Result(column = "dept_id", property = "deptId"),
            @Result(column = "create_time", property = "createTime"),
            @Result(column = "update_time", property = "updateTime")
    })
    @Select("select * from emp where id = #{id}")
    public Emp selectById(Integer id);
```

3. 开启驼峰命名：如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射。

这要保证数据库字段名是下划线a_column,并且java属性名是驼峰命名aColumn
```java
#开启mybatis的驼峰命名自动映射开关
mybatis.configuration.map-underscore-to-camel-case=true
```
### 条件查询
查询员工信息
#{name}会被?替代，但是？是不能出现在''里面的，所以用${name}, $是字符串拼接符号，不会预编译成?
不使用#{...}预编译，会出现问题：性能低、不安全、sql注入问题
解决办法: 使用sql的concat函数
```sql
select * from emp where name like '%张%' and gender = 1 and 
entrydate between '2010-01-01' and '2020-01-01' order by update_time desc;

```
```java
/**
     * 1. 条件查询员工
     * 1.1 根据输入的 员工姓名、员工性别、入职时间  搜索满足条件的员工信息。
     * 1.2 其中 员工姓名，支持模糊匹配； 性别 进行精确查询 ；入职时间 进行范围查询。
     * 1.3 支持分页查询。
     * 1.4 并对查询的结果，根据最后修改时间进行倒序排序。
     */
    //说明：#{name}会被?替代，但是？是不能出现在''里面的，所以用${name},$是字符串拼接符号，不会预编译成?
    //不使用#{...}预编译，会出现问题
    //解决办法，使用sql的concat函数
    @Select("select * from emp where name like concat('%',#{name},'%') and gender = #{gender} and " +
            "entrydate between #{begin} and #{end} order by update_time desc;")
    public List<Emp> list(String name, Short gender, LocalDate begin, LocalDate end);
```
```java
 @Test
    public void testList() {
        List<Emp> empList = empMapper.list("张",(short)1,
                LocalDate.of(2010,1,1),LocalDate.of(2020,1,1));
        System.out.println(empList);
    }
```
## XML映射文件
规范：

- XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1690100782006-2f2fb4b6-7f5c-45da-83de-b43b9f3535a3.png#averageHue=%233e444a&clientId=u337fbe84-3a6b-4&from=paste&height=321&id=u18d0dc42&originHeight=401&originWidth=412&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19204&status=done&style=none&taskId=uce12250f-f1bc-4a46-887a-701d31f454d&title=&width=329.6)

- XML映射文件的namespace属性为Mapper接口全类名一致。
- XML映射文件中sql语句的id与Mapper 接口中的方法名一致，并保持返回类型一致。
```xml
<mapper namespace="com.wmy.mapper.EmpMapper">

  <!--resultType:单条记录所封装的类型-->
  <select id="list" resultType="com.wmy.pojo.Emp">
    select * from emp where name like concat('%',#{name},'%') and gender = #{gender} and
    entrydate between #{begin} and #{end} order by update_time desc
  </select>
</mapper>
```
```java
public List<Emp> list(String name, Short gender, LocalDate begin, LocalDate end);
```
## 动态SQL
随着用户的输入或外部条件的变化而变化的SQL语句，我们称为 动态SQL。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1690102627333-01b7c64d-bd9b-4ad0-97c7-9847a73d9e8d.png#averageHue=%23faf4f3&clientId=u337fbe84-3a6b-4&from=paste&height=301&id=u943a0358&originHeight=376&originWidth=786&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=103931&status=done&style=none&taskId=u58c5aee0-8b51-4567-9b7f-0fcc011519c&title=&width=628.8)
要实现图中这样的查询功能，上面的sql语句写法是不行的
### <if><where><set>
<if>：
:::tips
用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL。
:::
<where>：
:::tips
where 元素只会在子元素有内容的情况下才插入where子句。而且会自动去除子句的开头的AND 或OR
:::
```xml
<mapper namespace="com.wmy.mapper.EmpMapper">

    <!--resultType:单条记录所封装的类型-->
    <select id="list" resultType="com.wmy.pojo.Emp">
        select *
        from emp
        <where>
            <if test="name != null">
                name like concat('%', #{name}, '%')
            </if>
            <if test="gender != null">
                and gender = #{gender}
            </if>
            <if test="begin != null and end != null">
                and entrydate between #{begin} and #{end}
            </if>
        </where>
        order by update_time desc
    </select>
</mapper>
```
<set>:
:::tips
动态地在行首插入 SET 关键字，并会删掉额外的逗号。（用在update语句中）
:::
动态更新员工信息：
```xml
<update id="update2">
        update emp
        <set>
            <if test="username != null">username = #{username},</if>
            <if test="name != null">name = #{name},</if>
            <if test="gender != null">gender = #{gender},</if>
            <if test="image != null">image = #{image},</if>
            <if test="job != null">job = #{job},</if>
            <if test="entrydate != null">entrydate = #{entrydate},</if>
            <if test="deptId != null">dept_id = #{deptId},</if>
            <if test="updateTime != null">update_time = #{updateTime}</if>
        </set>
        where id = #{id}
    </update>
```
### <foreach>
属性：
:::tips
collection:遍历的集合
item:遍历出来的元素
separator:分隔符
open:遍历开始前拼接的SQL片段
close:遍历结束后拼接的sql片段
:::
批量删除
```xml
<delete id="deleteByIds">
        delete from emp where id in
        <foreach collection="ids" item="id" separator="," open="(" close=")">
            #{id}
        </foreach>
    </delete>
```
```java
//EmpMapper接口方法
public void deleteByIds(List<Integer> ids);

//测试方法
@Test
    public void testDeleteByIds() {
        List<Integer> ids = Arrays.asList(18,19);
        empMapper.deleteByIds(ids);
    }
```
### <set><include>
 <sql>：定义可重用的 SQL 片段。
 <include>：通过属性refid，指定包含的sql片段。
取代select *,而查询的列太多，就把这个语句通过这两个标签装起来
动态查询
```xml
<sql id="commonSelect">
  select id, username, password, name, gender, image, job, 
         entrydate, dept_id deptId, create_time createTime, update_time updateTime
  from emp
</sql>

<!--resultType:单条记录所封装的类型-->
<select id="list" resultType="com.wmy.pojo.Emp">
  <include refid="commonSelect"/>
  <where>
    <if test="name != null">
      name like concat('%', #{name}, '%')
    </if>
    <if test="gender != null">
      and gender = #{gender}
    </if>
    <if test="begin != null and end != null">
      and entrydate between #{begin} and #{end}
    </if>
  </where>
  order by update_time desc
</select>
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35411832/1692606544597-3c3989ce-f461-4342-89fd-262fee5b55dc.png#averageHue=%23f4f2f5&clientId=u08c5b9bc-d639-4&from=paste&height=606&id=uf9772fdf&originHeight=757&originWidth=1736&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=473585&status=done&style=none&taskId=u97391d8f-afba-41d3-bf74-63b86a21b1a&title=&width=1388.8)

